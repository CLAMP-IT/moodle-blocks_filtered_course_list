<?php
// This file is part of Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * This file defines constants and classes used by the Filtered course list block.
 *
 * @package    block_filtered_course_list
 * @copyright  2016 CLAMP
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

defined('MOODLE_INTERNAL') || die();

define('BLOCK_FILTERED_COURSE_LIST_ADMIN_VIEW_ALL', 'all');
define('BLOCK_FILTERED_COURSE_LIST_ADMIN_VIEW_OWN', 'own');
define('BLOCK_FILTERED_COURSE_LIST_DEFAULT_LABELSCOUNT', 2);
define('BLOCK_FILTERED_COURSE_LIST_DEFAULT_CATEGORY', 0);
define('BLOCK_FILTERED_COURSE_LIST_EMPTY', '');
define('BLOCK_FILTERED_COURSE_LIST_FALSE', 0);
define('BLOCK_FILTERED_COURSE_LIST_TRUE', 1);

/**
 * An abstract class to generate rubrics based on a line of rubric config
 *
 * @package    block_filtered_course_list
 * @copyright  2016 CLAMP
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */
abstract class block_filtered_course_list_configline {
    /** @var array Elements of the rubric config line */
    public $line;
    /** @var array A list of courses the current user is enrolled in */
    public $courselist;
    /** @var array Config settings for the block */
    public $config;
    /** @var array A list of the rubric objects generated by the line */
    public $rubrics = array();

    /**
     * Constructor
     *
     * @param array $line The first element is the config type, the second is the rest of the line
     * @param array $courselist An array of courses the user is enrolled in
     * @param array $config Details of the block configuration
     */
    public function __construct($line, $courselist, $config) {
        $this->line = $this->validate_line($line);
        $this->courselist = $courselist;
        $this->config = $config;
    }

    /**
     * Each subclass must define its own line validation.
     * In general, the first element has already been validated or we wouldn't
     * have gotten to the right class.
     * Rubric titles will pass through htmlentities() when they need to, so no
     * need to innoculate them here.
     * Return a fixed-up array.
     *
     * @param array $line The array of line elements that has been passed to the constructor
     */
    abstract public function validate_line($line);

    /**
     * Each subclass must define how to get the right rubrics
     */
    abstract public function get_rubrics();

    /**
     * Validate expanded value
     * This should be similar for all subclasses.
     *
     * @param int $index The index of the $line array that should contain the expanded value
     * @param array $arr The line array
     */
    public function validate_expanded($index, &$arr) {
        if (!array_key_exists($index, $arr)) {
            $arr[$index] = 'collapsed';
        }
        $arr[$index] = (core_text::strpos($arr[$index], 'e') === 0) ? 'expanded' : 'collapsed';
    }
}

/**
 * A class to construct rubrics based on shortname matches
 *
 * @package    block_filtered_course_list
 * @copyright  2016 CLAMP
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */
class block_filtered_course_list_shortname_configline extends block_filtered_course_list_configline {

    /**
     * Validate the line
     *
     * @param array $line The array of line elements that has been passed to the constructor
     * @return array A fixed-up line array
     */
    public function validate_line($line) {
        $keys = array('expanded', 'label', 'match');
        $values = array_map(function($item) {
            return trim($item);
        }, explode('|', $line[1], 3));
        $this->validate_expanded(0, $values);
        if (!array_key_exists(1, $values)) {
            $values[1] = get_string('courses', 'block_filtered_course_list');
        }
        if (!array_key_exists(2, $values)) {
            $values[2] = '';
        }
        return array_combine($keys, $values);
    }

    /**
     * Populate the array of rubrics for this filter type
     *
     * @return array The list of rubric objects corresponding to the filter
     */
    public function get_rubrics() {
        $courselist = array_filter($this->courselist, function($course) {
            return (core_text::strpos($course->shortname, $this->line['match']) !== false);
        });
        if (empty($courselist)) {
            return null;
        }
        $this->rubrics[] = new block_filtered_course_list_rubric($this->line['label'],
                                        $courselist, $this->config, $this->line['expanded']);
        return $this->rubrics;
    }
}

/**
 * A class to construct rubrics based on shortname regex matches
 *
 * @package    block_filtered_course_list
 * @copyright  2016 CLAMP
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */
class block_filtered_course_list_regex_configline extends block_filtered_course_list_shortname_configline {

    /**
     * Populate the array of rubrics for this filter type
     *
     * @return array The list of rubric objects corresponding to the filter
     */
    public function get_rubrics() {
        $courselist = array_filter($this->courselist, function($course) {
            $teststring = str_replace('`', '', $this->line['match']);
            return (preg_match("`$teststring`", $course->shortname) == 1);
        });
        if (empty($courselist)) {
            return null;
        }
        $this->rubrics[] = new block_filtered_course_list_rubric($this->line['label'],
                                        $courselist, $this->config, $this->line['expanded']);
        return $this->rubrics;
    }
}

/**
 * A class to construct rubrics based on category structure
 *
 * @package    block_filtered_course_list
 * @copyright  2016 CLAMP
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */
class block_filtered_course_list_category_configline extends block_filtered_course_list_configline {

    /**
     * Validate the line
     *
     * @param array $line The array of line elements that has been passed to the constructor
     * @return array A fixed-up line array
     */
    public function validate_line($line) {
        $keys = array('expanded', 'catid', 'depth');
        $values = array_map(function($item) {
            return trim($item);
        }, explode('|', $line[1]));
        $this->validate_expanded(0, $values);
        foreach (array(1, 2) as $key) {
            if (!array_key_exists($key, $values)) {
                $values[$key] = '0';
            }
            $values[$key] = current(explode(" ", $values[$key]));
            if (!is_numeric($values[$key])) {
                $values[$key] = '0';
            }
        }
        return array_combine($keys, array_slice($values, 0, 3));
    }

    /**
     * Populate the array of rubrics for this filter type
     *
     * @return array The list of rubric objects corresponding to the filter
     */
    public function get_rubrics() {

        // We only need this for Moodle < 3.4.
        global $CFG;
        $moodleversion = $CFG->version;

        $categories = $this->_get_cat_and_descendants($this->line['catid'], $this->line['depth']);
        foreach ($categories as $category) {
            $rubricname = $category->name;
            if (isset($this->config->catrubrictpl) && $this->config->catrubrictpl != '') {
                $parent = coursecat::get($category->parent)->get_formatted_name();
                $separator = ' / ';
                if (isset($this->config->catseparator) && $this->config->catseparator != '') {
                    $separator = strip_tags($this->config->catseparator);
                }
                // Simplify the logic below when we drop support for Moodle 3.3.
                if ($moodleversion >= 2017111300) { // For Moodle >= 3.4.
                    $ancestry = $category->get_nested_name(false, $separator);
                } else { // For Moodle < 3.4.
                    $ancestors = coursecat::make_categories_list('', 0, $separator);
                    $ancestry = $ancestors[$category->id];
                }
                $replacements = array(
                    'NAME'     => $category->name,
                    'IDNUMBER' => $category->idnumber,
                    'PARENT'   => $parent,
                    'ANCESTRY' => $ancestry,
                );
                $rubricname = str_replace(array_keys($replacements), $replacements, $this->config->catrubrictpl);
                $rubricname = strip_tags($rubricname);
            }
            $courselist = array_filter($this->courselist, function($course) use($category) {
                return ($course->category == $category->id);
            });
            if (empty($courselist)) {
                continue;
            }
            $this->rubrics[] = new block_filtered_course_list_rubric($rubricname, $courselist,
                                                                $this->config, $this->line['expanded']);
        }

        return $this->rubrics;
    }

    /**
     * Fetch a category and all descendants visible to current usertype
     *
     * @param int $catid The id number of the category to fetch
     * @param int $depth How many generations of categories to show
     * @param array $accumulator An accumulator passed by reference to store the recursive results
     * @return array of coursecat objects
     */
    protected function _get_cat_and_descendants($catid=0, $depth=0, &$accumulator=array()) {

        if (!coursecat::get($catid, IGNORE_MISSING)) {
            return array();
        }

        // If $catid is 0, we have a special case. We will need to get all the top-level categories.
        // In the meantime, we don't start adding anything.
        if ($catid != 0) {
            $accumulator[$catid] = coursecat::get($catid);
        }

        // We do, however, need to pad any non-zero depth, since the first iteration is just prep.
        if ($catid == 0 && $depth > 0) {
            $depth++;
        }

        // If depth was zero then we will keep iterating until there are no more children..
        // Otherwise we bottom out when depth is 1.
        if ($depth != 1) {
            $children = coursecat::get($catid)->get_children();
            foreach ($children as $child) {
                $this->_get_cat_and_descendants($child->id, $depth - 1, $accumulator);
            }
        }

        return $accumulator;
    }
}

/**
 * A class to construct a rubric based on course completion
 *
 * @package    block_filtered_course_list
 * @copyright  2016 CLAMP
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */
class block_filtered_course_list_completion_configline extends block_filtered_course_list_configline {

    /**
     * Validate the line
     *
     * @param array $line The array of line elements that has been passed to the constructor
     * @return array A fixed-up line array
     */
    public function validate_line($line) {
        $keys = array('expanded', 'label', 'completionstate');
        $values = array_map(function($item) {
            return trim($item);
        }, explode('|', $line[1]));
        $this->validate_expanded(0, $values);
        if (!array_key_exists(1, $values)) {
            $values[1] = get_string('completedcourses', 'block_filtered_course_list');
        }
        if (!array_key_exists(2, $values)) {
            $values[2] = 'complete';
        }
        $values[2] = (core_text::strpos($values[2], 'c') === 0) ? '1' : '0';
        return array_combine($keys, $values);
    }

    /**
     * Populate the array of rubrics for this filter type
     *
     * @return array The list of rubric objects corresponding to the filter
     */
    public function get_rubrics() {
        global $USER;

        if (!completion_info::is_enabled_for_site()) {
            return null;
        }

        $courselist = array_filter($this->courselist, function($course) use($USER) {
            $completioninfo = new completion_info($course);
            if (!$completioninfo->is_enabled()) {
                return false;
            }
            return ($completioninfo->is_course_complete($USER->id) == $this->line['completionstate']);
        });
        if (empty($courselist)) {
            return null;
        }

        $this->rubrics[] = new block_filtered_course_list_rubric($this->line['label'], $courselist,
                                                                    $this->config, $this->line['expanded']);
        return $this->rubrics;
    }
}

/**
 * A class to construct a rubric for generic course and category lists
 *
 * @package    block_filtered_course_list
 * @copyright  2016 CLAMP
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */
class block_filtered_course_list_generic_configline extends block_filtered_course_list_configline {

    /**
     * Validate the line
     *
     * @param array $line The array of line elements that has been passed to the constructor
     * @return array A fixed-up line array
     */
    public function validate_line($line) {
        $keys = array('expanded', 'courselistheading', 'catlistheading');
        $values = array_map(function($item) {
            return trim($item);
        }, explode('|', $line[1]));
        $this->validate_expanded(0, $values);
        if (!array_key_exists(1, $values)) {
            $values[1] = get_string('courses');
            $values[1] = strip_tags($values[1]);
        }
        if (!array_key_exists(2, $values)) {
            $values[2] = get_string('categories');
            $values[2] = strip_tags($values[2]);
        }
        return array_combine($keys, $values);
    }

    /**
     * Populate the array of rubrics for this filter type
     *
     * @return array The list of rubric objects corresponding to the filter
     */
    public function get_rubrics() {

        // Parent = 0   ie top-level categories only.
        $categories = coursecat::get(0)->get_children();

        if ($categories) {
            // Just print top level category links.
            if (count($categories) > 1 ||
                    (count($categories) == 1 &&
                    current($categories)->coursecount > $this->config->maxallcourse)) {
                $label = $this->line['catlistheading'];
                $list = $categories;
                $this->rubrics[] = new block_filtered_course_list_rubric($label, $list, $this->config, $this->line['expanded']);
            } else {
                // Just print course names of single category.
                $category = array_shift($categories);
                $courses = get_courses($category->id);
                if ($courses) {
                    $label = $this->line['courselistheading'];
                    $list = $courses;
                    $this->rubrics[] = new block_filtered_course_list_rubric($label, $list, $this->config, $this->line['expanded']);
                }
            }
        }

        return $this->rubrics;
    }
}

/**
 * A class to structure rubrics regardless of their config type
 *
 * @package    block_filtered_course_list
 * @copyright  2016 CLAMP
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */
class block_filtered_course_list_rubric {
    /** @var string The rubric's title */
    public $title;
    /** @var array The subset of enrolled courses that match the filter criteria */
    public $courses = array();
    /** @var string Indicates whether the rubric is expanded or collapsed by default */
    public $expanded;
    /** @var array Config settings */
    public $config;

    /**
     * Constructor
     *
     * @param string $title The display title of the rubric
     * @param array $courses Courses the user is enrolled in that match the Filtered
     * @param array $config Block configuration
     * @param string $expanded Indicates the rubrics initial state: expanded or collapsed
     */
    public function __construct($title, $courses, $config, $expanded = false) {
        $this->title = $title;
        $this->courses = $courses;
        $this->config = $config;
        $this->expanded = $expanded;
    }
}

/**
 * Utility functions
 *
 * @package    block_filtered_course_list
 * @copyright  2017 CLAMP
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */
class block_filtered_course_list_lib {
    /**
     * Display a coursename according to the template
     *
     * @param object $course An object with all of the course attributes
     * @param string $tpl The coursename display template
     */
    public static function coursedisplaytext($course, $tpl) {
        if ($tpl == '') {
            $tpl = 'FULLNAME';
        }
        $cat = coursecat::get($course->category, IGNORE_MISSING);
        $catname = (is_object($cat)) ? $cat->name : '';
        $replacements = array(
            'FULLNAME'  => $course->fullname,
            'SHORTNAME' => $course->shortname,
            'IDNUMBER'  => $course->idnumber,
            'CATEGORY'  => $catname,
        );
        $displaytext = str_replace(array_keys($replacements), $replacements, $tpl);
        return strip_tags($displaytext);
    }
}
